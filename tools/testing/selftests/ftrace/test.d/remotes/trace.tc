#!/bin/sh
# SPDX-License-Identifier: GPL-2.0
# description: Test trace remote non-consuming read
# requires: remotes/test

. $TEST_DIR/remotes/functions

test_trace()
{
	echo 0 > tracing_on
    assert_unloaded

    echo 7 > buffer_size_kb
    echo 1 > tracing_on
    assert_loaded

    # Simple test: Emit few events and try to read them
    for i in $(seq 1 8); do
        echo $i > write_event
    done

    check_trace 1 8 trace

    #
    # Test interaction with consuming read
    #

    cat trace_pipe > /dev/null &
    pid=$!

    sleep 1
    kill $pid

    test $(wc -l < trace) -eq 0

    for i in $(seq 16 32); do
        echo $i > write_event
    done

    check_trace 16 32 trace

    #
    # Test interaction with reset
    #

    echo 0 > trace

    test $(wc -l < trace) -eq 0

    for i in $(seq 1 8); do
        echo $i > write_event
    done

    check_trace 1 8 trace

    #
    # Test interaction with lost events
    #

    # Ensure the writer is not on the reader page by reloading the buffer
    echo 0 > tracing_on
    echo 0 > trace
    assert_unloaded
    echo 1 > tracing_on
    assert_loaded

    # Ensure ring-buffer overflow by emitting events from the same CPU
    for cpu in $(get_cpu_ids); do
        break
    done

    events_per_page=$(($(get_page_size) / $(get_selftest_event_size))) # Approx: does not take TS into account
    nr_events=$(($events_per_page * 2))
    for i in $(seq 1 $nr_events); do
        taskset -c $cpu echo $i > write_event
    done

    id=$(sed -n -e '1s/\[[0-9]*\]\s*[0-9]*.[0-9]*: [a-z]* id=\([0-9]*\)/\1/p' trace)
    test $id -ne 1

    check_trace $id $nr_events trace

    #
    # Test per-CPU interface
    #
    echo 0 > trace

    for cpu in $(get_cpu_ids) ; do
        taskset -c $cpu echo $cpu > write_event
    done

    for cpu in $(get_cpu_ids); do
        cd per_cpu/cpu$cpu/

        check_trace $cpu $cpu trace

        cd - > /dev/null
    done

    #
    # Test with hotplug
    #

    [ "$(get_cpu_ids | wc -l)" -ge 2 ] || return 0

    echo 0 > trace

    for cpu in $(get_cpu_ids); do
        echo 0 > /sys/devices/system/cpu/cpu$cpu/online
        break
    done

    for i in $(seq 1 8); do
        echo $i > write_event
    done

    check_trace 1 8 trace

    echo 1 > /sys/devices/system/cpu/cpu$cpu/online
}

if [ -z "$SOURCE_REMOTE_TEST" ]; then
    set -e

    setup_remote_test
    test_trace
fi
